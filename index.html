<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Train</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Custom scrollbar for greyscale theme */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #171717; /* neutral-900 */
        }
        ::-webkit-scrollbar-thumb {
            background: #404040; /* neutral-700 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #525252; /* neutral-600 */
        }
    </style>
</head>
<body class="bg-neutral-950 text-neutral-100 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Icons (Inline SVGs) ---
        const Icon = ({ children, className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        // Train Icon (Front View)
        const Train = ({ className }) => (
            <Icon className={className}>
                <rect x="4" y="3" width="16" height="16" rx="2" />
                <path d="M4 11h16" />
                <path d="M12 3v8" />
                <path d="m8 19-2 3" />
                <path d="m16 19 2 3" />
                <circle cx="12" cy="15" r="2" />
            </Icon>
        );

        const Play = ({ className }) => (
            <Icon className={className}>
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </Icon>
        );
        const Pause = ({ className }) => (
            <Icon className={className}>
                <rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>
            </Icon>
        );
        const RotateCcw = ({ className }) => (
            <Icon className={className}>
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"></path><path d="M3 3v9h9"></path>
            </Icon>
        );
        const Plus = ({ className }) => (
            <Icon className={className}>
                <line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>
            </Icon>
        );
        const AlertCircle = ({ className }) => (
            <Icon className={className}>
                <circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>
            </Icon>
        );
        const Dumbbell = ({ className }) => (
            <Icon className={className}>
                <path d="m6.5 6.5 11 11"></path><path d="m21 21-1-1"></path><path d="m3 3 1 1"></path><path d="m18 22 4-4"></path><path d="m2 6 4-4"></path><path d="m3 10 7-7"></path><path d="m14 21 7-7"></path>
            </Icon>
        );
        const Sparkles = ({ className }) => (
            <Icon className={className}>
                <path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"></path><path d="M5 3v4"></path><path d="M9 5h4"></path><path d="M3 7h4"></path>
            </Icon>
        );
        const Wind = ({ className }) => (
            <Icon className={className}>
                <path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2" />
                <path d="M9.6 4.6A2 2 0 1 1 11 8H2" />
                <path d="M12.6 19.4A2 2 0 1 0 14 16H2" />
            </Icon>
        );
        const Volume2 = ({ className }) => (
            <Icon className={className}>
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </Icon>
        );
        const Bell = ({ className }) => (
            <Icon className={className}>
                <path d="M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9"></path>
                <path d="M10.3 21a1.94 1.94 0 0 0 3.4 0"></path>
            </Icon>
        );
        const ToggleLeft = ({ className }) => (
            <Icon className={className}>
                <rect width="20" height="12" x="2" y="6" rx="6" ry="6"></rect>
                <circle cx="8" cy="12" r="2"></circle>
            </Icon>
        );
        const ToggleRight = ({ className }) => (
            <Icon className={className}>
                <rect width="20" height="12" x="2" y="6" rx="6" ry="6"></rect>
                <circle cx="16" cy="12" r="2"></circle>
            </Icon>
        );
        const Moon = ({ className }) => (
            <Icon className={className}>
                <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
            </Icon>
        );
        const Sun = ({ className }) => (
             <Icon className={className}>
                <circle cx="12" cy="12" r="4"></circle>
                <path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41-1.41"></path><path d="m19.07 4.93-1.41 1.41"></path>
            </Icon>
        );
        const Shuffle = ({ className }) => (
            <Icon className={className}>
                <path d="M16 3h5v5"></path>
                <path d="M4 20 21 3"></path>
                <path d="M21 16v5h-5"></path>
                <path d="M15 15l-5 5"></path>
                <path d="M4 4l5 5"></path>
            </Icon>
        );


        // --- Main Component ---
        const TimeTrain = () => {
            const [inputString, setInputString] = useState("");
            const [timers, setTimers] = useState([]);
            const [currentIndex, setCurrentIndex] = useState(0);
            const [isRunning, setIsRunning] = useState(false);
            const [timeLeft, setTimeLeft] = useState(0);
            const [error, setError] = useState("");
            const [countdownEnabled, setCountdownEnabled] = useState(true);
            const [keepAwake, setKeepAwake] = useState(true);
            const [toneType, setToneType] = useState('standard'); // 'standard', 'zen', 'retro'
            
            const intervalRef = useRef(null);
            const audioCtxRef = useRef(null);
            const endTimeRef = useRef(null);
            const lastSecondRef = useRef(null); // Track last second played for countdown
            
            const wakeLockRef = useRef(null);
            const silentAudioRef = useRef(null);

            // --- Random Logic Helper ---
            const getRandomDurationString = () => {
                const r = Math.random();
                if (r < 0.3) {
                    // Seconds only (10s - 90s)
                    return `${Math.floor(Math.random() * 81) + 10}s`;
                } else if (r < 0.6) {
                    // Minutes only (1m - 60m)
                    return `${Math.floor(Math.random() * 60) + 1}m`;
                } else if (r < 0.9) {
                    // Minutes and Seconds
                    return `${Math.floor(Math.random() * 10) + 1}m ${Math.floor(Math.random() * 50) + 10}s`;
                } else {
                    // Hours (Rare)
                    return `1h ${Math.floor(Math.random() * 30)}m`;
                }
            };

            const generateRandomPreset = () => {
                const structure = Math.random();
                
                if (structure < 0.25) {
                    // Single Long Timer
                    return `${getRandomDurationString()}`;
                } else if (structure < 0.5) {
                    // Simple Sequence (3-5 items)
                    const count = Math.floor(Math.random() * 3) + 3;
                    let seq = [];
                    for(let i=0; i<count; i++) {
                        seq.push(`${getRandomDurationString()}`);
                    }
                    return seq.join(", ");
                } else {
                    // Sets / Loop
                    const work = getRandomDurationString();
                    const rest = `${Math.floor(Math.random() * 45) + 15}s`;
                    const reps = Math.floor(Math.random() * 6) + 3; // 3-8 reps
                    return `[${work}, ${rest}]x${reps}`;
                }
            };

            // --- Background Audio Hack ---
            // To keep iOS timers alive, we play a silent HTML5 audio track in a loop.
            // This grants "background execution" privileges to the tab.
            const toggleSilentAudio = (shouldPlay) => {
                if (!silentAudioRef.current) {
                    const audio = new Audio("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
                    audio.loop = true;
                    silentAudioRef.current = audio;
                }
                
                if (shouldPlay) {
                    silentAudioRef.current.play().catch(e => console.log("Silent audio play failed", e));
                } else {
                    silentAudioRef.current.pause();
                }
            };

            // --- Wake Lock Logic ---
            const requestWakeLock = async () => {
                // Feature check
                if (!('wakeLock' in navigator)) return;

                try {
                    const lock = await navigator.wakeLock.request('screen');
                    wakeLockRef.current = lock;
                    lock.addEventListener('release', () => {
                        console.log('Wake Lock was released');
                    });
                    console.log('Wake Lock is active');
                } catch (err) {
                    // Gracefully handle permission errors (common in restricted iframes)
                    console.warn(`Wake Lock request failed: ${err.name}, ${err.message}`);
                    // We consume the error so it doesn't break execution.
                    // The timer will continue running via the silent audio fallback regardless.
                }
            };

            const releaseWakeLock = async () => {
                if (wakeLockRef.current) {
                    try {
                        await wakeLockRef.current.release();
                        wakeLockRef.current = null;
                    } catch (err) {
                        console.error(`${err.name}, ${err.message}`);
                    }
                }
            };

            // Re-acquire lock if tab becomes visible again and we should be running with Keep Awake on
            useEffect(() => {
                const handleVisibilityChange = () => {
                    if (document.visibilityState === 'visible' && isRunning && keepAwake) {
                        requestWakeLock();
                    }
                };
                document.addEventListener('visibilitychange', handleVisibilityChange);
                return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
            }, [isRunning, keepAwake]);
            
            // Separate Effect for Wake Lock to avoid resetting timer on toggle
            useEffect(() => {
                if (isRunning && keepAwake) {
                    requestWakeLock();
                } else {
                    releaseWakeLock();
                }
                
                return () => {
                   // Clean up on unmount or logic change - we rely on the if/else above usually,
                   // but release on unmount is safe.
                   releaseWakeLock(); 
                }
            }, [isRunning, keepAwake]);


            const parseDuration = (str) => {
                const regex = /(\d+)\s*(h|m|s)/g;
                let totalSeconds = 0;
                let match;
                let found = false;

                while ((match = regex.exec(str)) !== null) {
                    found = true;
                    const value = parseInt(match[1]);
                    const unit = match[2];
                    if (unit === 'h') totalSeconds += value * 3600;
                    if (unit === 'm') totalSeconds += value * 60;
                    if (unit === 's') totalSeconds += value;
                }
                
                if (!found) {
                    const simpleNum = parseInt(str.trim());
                    if (!isNaN(simpleNum)) return simpleNum;
                    return 0;
                }

                return totalSeconds;
            };

            const processSequence = (str) => {
                setIsRunning(false);
                setCurrentIndex(0);
                setError("");

                if (!str.trim()) {
                    setTimers([]);
                    return;
                }

                let expandedStr = str;

                // --- Keyword Logic: Settings ---
                // Check for toggle keywords and remove them
                if (expandedStr.match(/count\+/i)) {
                    setCountdownEnabled(true);
                    expandedStr = expandedStr.replace(/count\+/gi, '');
                }
                if (expandedStr.match(/count-/i)) {
                    setCountdownEnabled(false);
                    expandedStr = expandedStr.replace(/count-/gi, '');
                }
                if (expandedStr.match(/awake\+/i)) {
                    setKeepAwake(true);
                    expandedStr = expandedStr.replace(/awake\+/gi, '');
                }
                if (expandedStr.match(/awake-/i)) {
                    setKeepAwake(false);
                    expandedStr = expandedStr.replace(/awake-/gi, '');
                }

                // Expand groups: [timer1, timer2]xN
                // Supports nesting by looping until no brackets remain (e.g., [[10s]x2]x2)
                const groupRegex = /\[([^\]]+)\]\s*[xX*]\s*(\d+)/g;
                
                let iterations = 0;
                while (expandedStr.match(groupRegex) && iterations < 10) { 
                    expandedStr = expandedStr.replace(groupRegex, (match, content, count) => {
                        const repetitions = parseInt(count, 10);
                        if (isNaN(repetitions) || repetitions <= 0) return "";
                        return Array(repetitions).fill(content).join(", ");
                    });
                    iterations++;
                }

                // Handle "random" keyword anywhere in string
                // We do this AFTER expansion so [random]x3 generates 3 unique times
                expandedStr = expandedStr.replace(/random/gi, () => getRandomDurationString());

                const parts = expandedStr.split(',');
                const newTimers = parts.map((part, index) => {
                    const labelMatch = part.match(/\((.*?)\)/);
                    const label = labelMatch ? labelMatch[1].trim() : '';
                    const timePart = part.replace(/\(.*?\)/g, '');
                    const duration = parseDuration(timePart);

                    return {
                        id: index,
                        originalText: part.trim(),
                        label: label,
                        duration: duration,
                        status: 'pending' 
                    };
                }).filter(t => t.duration > 0);

                if (newTimers.length === 0 && str.trim().length > 0) {
                    setError("Could not understand the time format. Try '10s', '1m', or sets like '[1m (Work), 1m (Rest)]x3'.");
                }

                setTimers(newTimers);
                if (newTimers.length > 0) {
                    setTimeLeft(newTimers[0].duration);
                }
            };

            const handleManualUpdate = () => {
                processSequence(inputString);
            };

            const loadPreset = (presetString) => {
                setInputString(presetString);
                processSequence(presetString);
            };

            const initAudio = () => {
                if (!audioCtxRef.current) {
                    audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioCtxRef.current.state === 'suspended') {
                    audioCtxRef.current.resume();
                }
            };

            const playSound = (type) => {
                if (!audioCtxRef.current) return;
                
                const ctx = audioCtxRef.current;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.connect(gain);
                gain.connect(ctx.destination);

                const now = ctx.currentTime;

                if (type === 'chirp') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(880, now);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    return;
                }

                if (toneType === 'standard') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(523.25, now);
                    osc.frequency.exponentialRampToValueAtTime(1046.5, now + 0.1);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                } 
                else if (toneType === 'zen') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(220, now); 
                    osc.frequency.linearRampToValueAtTime(440, now + 0.05); 
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.5); 
                    osc.start(now);
                    osc.stop(now + 1.5);
                }
                else if (toneType === 'retro') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(440, now);
                    osc.frequency.setValueAtTime(880, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now);
                    osc.stop(now + 0.3);
                }
            };

            const toggleTimer = () => {
                initAudio();
                if (timers.length === 0) processSequence(inputString);
                
                if (isRunning) {
                    setIsRunning(false);
                } else {
                    if (currentIndex >= timers.length) {
                        setCurrentIndex(0);
                        setTimeLeft(timers[0]?.duration || 0);
                    }
                    setIsRunning(true);
                }
            };

            const reset = () => {
                setIsRunning(false);
                setCurrentIndex(0);
                lastSecondRef.current = null;
                if (timers.length > 0) {
                    setTimeLeft(timers[0].duration);
                }
            };

            // --- MAIN LOOP ---
            useEffect(() => {
                if (isRunning && currentIndex < timers.length) {
                    // Activate Silent Audio ALWAYS when running
                    toggleSilentAudio(true);

                    endTimeRef.current = Date.now() + timeLeft * 1000;
                    lastSecondRef.current = timeLeft; 

                    intervalRef.current = setInterval(() => {
                        const now = Date.now();
                        const distance = endTimeRef.current - now;
                        const currentSec = Math.ceil(distance / 1000);

                        // Countdown Chirp Logic
                        if (countdownEnabled && currentSec <= 5 && currentSec > 0) {
                            if (currentSec !== lastSecondRef.current) {
                                playSound('chirp');
                                lastSecondRef.current = currentSec;
                            }
                        }

                        if (distance <= 0) {
                            playSound('main');
                            const nextIndex = currentIndex + 1;
                            
                            if (nextIndex < timers.length) {
                                setCurrentIndex(nextIndex);
                                const nextDuration = timers[nextIndex].duration;
                                setTimeLeft(nextDuration);
                                lastSecondRef.current = nextDuration;
                                endTimeRef.current = now + nextDuration * 1000;
                            } else {
                                setTimeLeft(0);
                                setIsRunning(false);
                                setCurrentIndex(nextIndex);
                                clearInterval(intervalRef.current);
                            }
                        } else {
                            setTimeLeft(currentSec);
                            if (currentSec !== lastSecondRef.current) {
                                lastSecondRef.current = currentSec;
                            }
                        }
                    }, 100);
                } else {
                    clearInterval(intervalRef.current);
                    toggleSilentAudio(false);
                }

                return () => {
                    clearInterval(intervalRef.current);
                    toggleSilentAudio(false);
                };
            }, [isRunning, currentIndex, timers, countdownEnabled, toneType]); // removed keepAwake from here to prevent reset

            useEffect(() => {
                processSequence(inputString);
            }, []);

            const formatTime = (seconds) => {
                if (seconds <= 0) return "00:00";
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = seconds % 60;

                if (h > 0) {
                    return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
                }
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            const getProgress = () => {
                if (currentIndex >= timers.length) return 100;
                const currentTotal = timers[currentIndex]?.duration || 1;
                const progress = ((currentTotal - timeLeft) / currentTotal) * 100;
                return Math.min(100, Math.max(0, progress));
            };

            const cycleTone = () => {
                initAudio();
                const tones = ['standard', 'zen', 'retro'];
                const nextIndex = (tones.indexOf(toneType) + 1) % tones.length;
                const newTone = tones[nextIndex];
                setToneType(newTone);
                
                setTimeout(() => {
                     if (!audioCtxRef.current) return;
                     const ctx = audioCtxRef.current;
                     const osc = ctx.createOscillator();
                     const gain = ctx.createGain();
                     osc.connect(gain);
                     gain.connect(ctx.destination);
                     const now = ctx.currentTime;
                     
                     if (newTone === 'standard') {
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(523.25, now);
                        osc.frequency.exponentialRampToValueAtTime(1046.5, now + 0.1);
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
                        osc.start(now);
                        osc.stop(now + 0.5);
                     } else if (newTone === 'zen') {
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(220, now); 
                        osc.frequency.linearRampToValueAtTime(440, now + 0.05); 
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.5); 
                        osc.start(now);
                        osc.stop(now + 1.5);
                     } else if (newTone === 'retro') {
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(440, now);
                        osc.frequency.setValueAtTime(880, now + 0.1);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                     }
                }, 100);
            };

            return (
                <div className="min-h-screen bg-neutral-950 text-neutral-100 p-4 md:p-8 font-mono selection:bg-neutral-600 selection:text-white">
                    <div className="max-w-2xl mx-auto space-y-8">
                        
                        {/* Header */}
                        <div className="text-center space-y-2">
                            <h1 className="text-3xl font-bold tracking-tight text-white flex items-center justify-center gap-3">
                                <Train className="w-8 h-8" />
                                <a href="https://github.com/santacrows/timetrain/blob/main/README.md">Time Train</a>
                            </h1>
                        </div>

                        {/* Controls Section */}
                        <div className="space-y-4">
                            {/* Quick Presets */}
                            <div className="flex gap-4 justify-center flex-wrap">
                                <button 
                                    onClick={() => loadPreset(generateRandomPreset())}
                                    className="flex items-center gap-2 bg-neutral-800 hover:bg-neutral-700 text-neutral-300 border border-neutral-700 px-4 py-2 rounded-full text-sm font-medium transition-colors"
                                >
                                    <Shuffle className="w-4 h-4" />
                                    Random
                                </button>
                                <button 
                                    onClick={() => loadPreset("10s (Get Ready), 1m (Jump), 1m (Rest), 1m (Jump), 1m (Rest), 1m (Jump), 1m (Rest), 1m (Jump)")}
                                    className="flex items-center gap-2 bg-neutral-800 hover:bg-neutral-700 text-neutral-300 border border-neutral-700 px-4 py-2 rounded-full text-sm font-medium transition-colors"
                                >
                                    <Dumbbell className="w-4 h-4" />
                                    Jump Rope
                                </button>
                                <button 
                                    onClick={() => loadPreset("10s (Preparing to Walk), 15m (Walking), 20s (Preparing to Sit), 15m (Sitting), count-, awake-")}
                                    className="flex items-center gap-2 bg-neutral-800 hover:bg-neutral-700 text-neutral-300 border border-neutral-700 px-4 py-2 rounded-full text-sm font-medium transition-colors"
                                >
                                    <Sparkles className="w-4 h-4" />
                                    Meditation
                                </button>
                                <button 
                                    onClick={() => loadPreset("10s (Get Ready), 2m (Bounce), 1m (Alternating Arm Swings), 1m (High March), 1m (Plié), 1m (Rag Doll), 1m (Golf Swing), 1m (Body Wave), 1m (Trunk Twist), 2m (Jump + Hip Twist)")}
                                    className="flex items-center gap-2 bg-neutral-800 hover:bg-neutral-700 text-neutral-300 border border-neutral-700 px-4 py-2 rounded-full text-sm font-medium transition-colors"
                                >
                                    <Wind className="w-4 h-4" />
                                    Qi Flow
                                </button>
                            </div>

                            {/* Input Box */}
                            <div className="bg-neutral-900 rounded-2xl p-6 shadow-xl border border-neutral-800">
                                <div className="flex gap-2 flex-col sm:flex-row">
                                    <input
                                    type="text"
                                    value={inputString}
                                    onChange={(e) => setInputString(e.target.value)}
                                    placeholder="e.g. 10s, [1m (Work), 30s (Rest)]x5"
                                    className="flex-1 bg-neutral-950 border-neutral-800 border rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-neutral-500 text-neutral-100 placeholder-neutral-600 font-mono"
                                    />
                                    <button
                                    onClick={handleManualUpdate}
                                    className="bg-neutral-800 hover:bg-neutral-700 text-white px-6 py-3 rounded-lg font-medium transition-colors flex items-center justify-center gap-2 border border-neutral-700"
                                    >
                                    <Plus className="w-4 h-4" />
                                    Update
                                    </button>
                                </div>
                                {error && (
                                    <div className="mt-3 text-red-400 text-sm flex items-center gap-2">
                                    <AlertCircle className="w-4 h-4" />
                                    {error}
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* Main Display */}
                        <div className="bg-neutral-900 rounded-3xl p-8 shadow-2xl border border-neutral-800 text-center relative overflow-hidden">
                            {/* Background Progress Bar - High Contrast White/Grey */}
                            <div 
                                className="absolute top-0 left-0 h-1 bg-white transition-all duration-100 ease-linear"
                                style={{ width: `${getProgress()}%` }}
                            />
                            
                            {/* Wake Lock Indicator (Subtle) */}
                            {keepAwake && isRunning && (
                                <div className="absolute top-4 right-4 flex items-center gap-1.5 px-2 py-1 bg-neutral-800/80 rounded-full text-[10px] text-green-400 border border-green-900/30 shadow-sm backdrop-blur-sm pointer-events-none">
                                    <span className="relative flex h-2 w-2">
                                      <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                                      <span className="relative inline-flex rounded-full h-2 w-2 bg-green-500"></span>
                                    </span>
                                    Active
                                </div>
                            )}

                            <div className="space-y-2 mb-8">
                                <div className="text-sm font-medium text-neutral-400 uppercase tracking-wider">
                                    {currentIndex >= timers.length ? "Sequence Complete" : `Timer ${currentIndex + 1} of ${timers.length}`}
                                </div>
                                <div className="text-7xl md:text-8xl font-mono font-bold tracking-tighter text-white tabular-nums">
                                    {formatTime(timeLeft)}
                                </div>
                                {/* Dynamic Label Display */}
                                <div className="h-8 flex items-center justify-center">
                                {timers[currentIndex] ? (
                                    timers[currentIndex].label ? (
                                        <span className="text-xl md:text-3xl font-semibold text-neutral-300">
                                            {timers[currentIndex].label}
                                        </span>
                                    ) : (
                                        <span className="text-neutral-600 text-lg">
                                            ⏱
                                        </span>
                                    )
                                ) : (
                                    <span className="text-neutral-300 font-medium">All Done</span>
                                )}
                                </div>
                            </div>

                            {/* Controls */}
                            <div className="flex flex-col gap-6">
                                <div className="flex items-center justify-center gap-4">
                                    <button
                                        onClick={toggleTimer}
                                        disabled={timers.length === 0}
                                        className={`
                                            w-16 h-16 rounded-full flex items-center justify-center transition-all shadow-lg
                                            ${isRunning 
                                                ? 'bg-neutral-200 hover:bg-white text-black' 
                                                : 'bg-white hover:bg-neutral-200 text-black'
                                            }
                                            ${timers.length === 0 ? 'opacity-50 cursor-not-allowed' : ''}
                                        `}
                                    >
                                        {isRunning ? <Pause className="w-8 h-8 fill-current" /> : <Play className="w-8 h-8 fill-current ml-1" />}
                                    </button>
                                    
                                    <button
                                        onClick={reset}
                                        className="w-12 h-12 rounded-full bg-neutral-800 hover:bg-neutral-700 text-neutral-300 border border-neutral-700 flex items-center justify-center transition-all shadow-lg"
                                    >
                                        <RotateCcw className="w-5 h-5" />
                                    </button>
                                </div>

                                {/* Settings Row */}
                                <div className="flex items-center justify-center gap-6 pt-2 border-t border-neutral-800 flex-wrap">
                                    {/* Countdown Toggle */}
                                    <button 
                                        onClick={() => setCountdownEnabled(!countdownEnabled)}
                                        className="flex items-center gap-2 text-sm text-neutral-400 hover:text-white transition-colors group"
                                        title="Toggle 5s Countdown Chirp"
                                    >
                                        <Bell className={`w-4 h-4 ${countdownEnabled ? 'text-white' : 'text-neutral-600'}`} />
                                        <span>5s Count</span>
                                        {countdownEnabled ? <ToggleRight className="w-6 h-6 text-green-500" /> : <ToggleLeft className="w-6 h-6 text-neutral-600" />}
                                    </button>

                                    {/* Keep Awake Toggle (Screen Lock Only) */}
                                    <button 
                                        onClick={() => setKeepAwake(!keepAwake)}
                                        className="flex items-center gap-2 text-sm text-neutral-400 hover:text-white transition-colors group"
                                        title="Keeps screen on while running"
                                    >
                                        {keepAwake ? <Sun className="w-4 h-4 text-white" /> : <Moon className="w-4 h-4 text-neutral-600" />}
                                        <span>Keep Awake</span>
                                        {keepAwake ? <ToggleRight className="w-6 h-6 text-green-500" /> : <ToggleLeft className="w-6 h-6 text-neutral-600" />}
                                    </button>

                                    {/* Tone Selector */}
                                    <button 
                                        onClick={cycleTone}
                                        className="flex items-center gap-2 text-sm text-neutral-400 hover:text-white transition-colors"
                                        title="Cycle Main Alarm Tone"
                                    >
                                        <Volume2 className="w-4 h-4" />
                                        <span className="capitalize w-16 text-left">{toneType}</span>
                                    </button>
                                </div>
                            </div>
                        </div>

                        {/* Queue List */}
                        <div className="space-y-3">
                            <h3 className="text-sm font-medium text-neutral-500 uppercase tracking-wider ml-1">Up Next</h3>
                            <div className="grid gap-2">
                                {timers.map((timer, idx) => {
                                    const isActive = idx === currentIndex;
                                    const isPast = idx < currentIndex;
                                    
                                    return (
                                        <div 
                                            key={idx}
                                            className={`
                                                p-4 rounded-xl flex items-center justify-between border transition-all
                                                ${isActive 
                                                    ? 'bg-neutral-800 border-white/40 shadow-[0_0_10px_rgba(255,255,255,0.1)]' 
                                                    : isPast
                                                        ? 'bg-neutral-900/50 border-neutral-800/50 opacity-40'
                                                        : 'bg-neutral-900 border-neutral-800'
                                                }
                                            `}
                                        >
                                            <div className="flex items-center gap-3">
                                                <div className={`
                                                    w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold shrink-0
                                                    ${isActive ? 'bg-white text-black' : 'bg-neutral-800 text-neutral-500'}
                                                `}>
                                                    {idx + 1}
                                                </div>
                                                <span className={`font-medium truncate ${isActive ? 'text-white' : 'text-neutral-400'}`}>
                                                    {timer.label || timer.originalText}
                                                </span>
                                            </div>
                                            <div className="font-mono text-neutral-500 text-sm whitespace-nowrap">
                                                {formatTime(timer.duration)}
                                            </div>
                                        </div>
                                    );
                                })}
                                {timers.length === 0 && (
                                    <div className="text-center py-8 text-neutral-600 border-2 border-dashed border-neutral-900 rounded-xl">
                                        No timers added yet.
                                    </div>
                                )}
                            </div>
                        </div>

                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TimeTrain />);
    </script>
    
</body>
</html>
